import type { DBParticipantInsert } from './store/schema'
import type { IGAttachment, IGMessage, IGThread } from './ig-types'
import { IGContact } from './ig-types'
import { fixEmoji, getAsDate, getAsMS, getAsString, getInboxNameFromIGFolder, parseValue } from './util'

type RawItem = string[]

type SearchArgumentType = 'user' | 'group' | 'unknown_user'

const parseMap = {
  deleteThenInsertThread: (a: RawItem) => {
    const t: IGThread = {
      raw: JSON.stringify(a),
      // isUnread: Number(a[0][1]) > Number(a[1][1]),
      threadKey: a[7][1],
      lastReadWatermarkTimestampMs: getAsMS(a[1][1]),
      // threadType: a[9][1] === '1' ? 'single' : 'group',
      threadType: a[9][1],
      folderName: getInboxNameFromIGFolder(parseValue<string>(a[10])),
      parentThreadKey: parseValue<string>(a[35]),
      lastActivityTimestampMs: getAsMS(a[0][1]),
      snippet: a[2],
      threadName: a[3][1],
      threadPictureUrl: getAsString(a[4]),
      needsAdminApprovalForNewParticipant: Boolean(a[5][1]),
      threadPictureUrlFallback: a[11],
      threadPictureUrlExpirationTimestampMs: getAsMS(a[12][1]),
      removeWatermarkTimestampMs: getAsMS(a[13][1]),
      muteExpireTimeMs: getAsMS(a[14][1]),
      // muteCallsExpireTimeMs: getAsMS(a[15][1]),
      groupNotificationSettings: a[16][1],
      isAdminSnippet: Boolean(a[17][1]),
      snippetSenderContactId: a[18][1],
      snippetStringHash: a[21][1],
      snippetStringArgument1: a[22][1],
      snippetAttribution: a[23][1],
      snippetAttributionStringHash: a[24][1],
      disappearingSettingTtl: Number(a[25][1]),
      disappearingSettingUpdatedTs: getAsMS(a[26][1]),
      disappearingSettingUpdatedBy: a[27][1],
      cannotReplyReason: a[30][1],
      customEmoji: a[31][1],
      customEmojiImageUrl: a[32][1],
      outgoingBubbleColor: a[33][1],
      themeFbid: a[34][1],
      authorityLevel: 0,
      mailboxType: a[8][1],
      muteMentionExpireTimeMs: getAsMS(a[15][1]),
      muteCallsExpireTimeMs: getAsMS(a[16][1]),
      ongoingCallState: a[32][1],
      nullstateDescriptionText1: a[39][1],
      nullstateDescriptionType1: a[40][1],
      nullstateDescriptionText2: a[41][1],
      nullstateDescriptionType2: a[42][1],
      nullstateDescriptionText3: a[43],
      nullstateDescriptionType3: a[44],
      draftMessage: a[45],
      snippetHasEmoji: Boolean(a[46][1]),
      hasPersistentMenu: Boolean(a[47][1]),
      disableComposerInput: Boolean(a[48][1]),
      cannotUnsendReason: a[49][1],
      viewedPluginKey: a[50][1],
      viewedPluginContext: a[51][1],
      clientThreadKey: a[52][1],
      capabilities: a[53],
      shouldRoundThreadPicture: Boolean(a[54][1]),
      proactiveWarningDismissTime: Number(a[55][1]),
      isCustomThreadPicture: Boolean(a[56][1]),
      otidOfFirstMessage: a[57][1],
      normalizedSearchTerms: a[58],
      additionalThreadContext: a[59][1],
      disappearingThreadKey: a[60][1],
      isDisappearingMode: Boolean(a[61][1]),
      disappearingModeInitiator: a[62][1],
      unreadDisappearingMessageCount: Number(a[63][1]),
      lastMessageCtaId: a[65][1],
      lastMessageCtaType: a[66][1],
      lastMessageCtaTimestampMs: getAsMS(a[67][1]),
      consistentThreadFbid: a[68][1],
      threadDescription: a[70][1],
      unsendLimitMs: getAsMS(a[71][1]),
      capabilities2: a[79][1],
      capabilities3: a[80][1],
      syncGroup: a[83],
      threadInvitesEnabled: Boolean(a[84]),
      threadInviteLink: a[85],
      isAllUnreadMessageMissedCallXma: Boolean(a[86]),
      lastNonMissedCallXmaMessageTimestampMs: getAsMS(a[87]),
      threadInvitesEnabledV2: Boolean(a[89]),
      hasPendingInvitation: Boolean(a[92]),
      eventStartTimestampMs: getAsMS(a[93]),
      eventEndTimestampMs: getAsMS(a[94]),
      takedownState: a[95],
      secondaryParentThreadKey: a[96],
      igFolder: a[97],
      inviterId: a[98],
      threadTags: a[99],
      threadStatus: a[100],
      threadSubtype: a[101],
      pauseThreadTimestamp: getAsMS(a[102]),
    }

    if (Array.isArray(a[3])) {
      t.threadName = null
    } else {
      // eslint-disable-next-line prefer-destructuring
      t.threadName = a[3]
    }

    return t
    // loop through the keys and if the value is
  },
  upsertMessage: (a: RawItem): IGMessage => ({
    raw: JSON.stringify(a),
    links: null,
    threadKey: parseValue<string>(a[3]),
    timestampMs: getAsMS(parseValue<string>(a[5])),
    messageId: parseValue<string>(a[8]),
    offlineThreadingId: parseValue<string>(a[9]),
    authorityLevel: parseValue(a[2]),
    primarySortKey: parseValue<string>(a[6]),
    senderId: parseValue<string>(a[10]),
    isAdminMessage: parseValue<boolean>(a[12]),
    sendStatus: parseValue<string>(a[15]),
    sendStatusV2: parseValue<string>(a[16]),
    text: parseValue<string>(a[0]),
    subscriptErrorMessage: parseValue<string>(a[1]),
    secondarySortKey: parseValue<string>(a[7]),
    stickerId: parseValue<string>(a[11]),
    messageRenderingType: parseValue<string>(a[13]),
    isUnsent: parseValue<boolean>(a[17]),
    unsentTimestampMs: getAsMS(parseValue<string>(a[18])),
    mentionOffsets: parseValue<string>(a[19]),
    mentionLengths: parseValue<string>(a[20]),
    mentionIds: parseValue<string>(a[21]),
    mentionTypes: parseValue<string>(a[22]),
    replySourceId: parseValue<string>(a[23]),
    replySourceType: parseValue<string>(a[24]),
    replySourceTypeV2: parseValue<string>(a[25]),
    replyStatus: parseValue<string>(a[26]),
    replySnippet: parseValue<string>(a[27]),
    replyMessageText: parseValue<string>(a[28]),
    replyToUserId: parseValue<string>(a[29]),
    replyMediaExpirationTimestampMs: getAsMS(parseValue<string>(a[30])),
    replyMediaUrl: parseValue<string>(a[31]),
    replyMediaPreviewWidth: parseValue<string>(a[33]),
    replyMediaPreviewHeight: parseValue<string>(a[34]),
    replyMediaUrlMimeType: parseValue<string>(a[35]),
    replyMediaUrlFallback: parseValue<string>(a[36]),
    replyCtaId: parseValue<string>(a[37]),
    replyCtaTitle: parseValue<string>(a[38]),
    replyAttachmentType: parseValue<string>(a[39]),
    replyAttachmentId: parseValue<string>(a[40]),
    replyAttachmentExtra: parseValue<string>(a[41]),
    replyType: parseValue<string>(a[42]),
    isForwarded: parseValue<boolean>(a[43]),
    forwardScore: parseValue<string>(a[44]),
    hasQuickReplies: parseValue<boolean>(a[45]),
    adminMsgCtaId: parseValue<string>(a[46]),
    adminMsgCtaTitle: parseValue<string>(a[47]),
    adminMsgCtaType: parseValue<string>(a[48]),
    cannotUnsendReason: parseValue<string>(a[49]),
    textHasLinks: parseValue<number>(a[50]),
    viewFlags: parseValue<string>(a[51]),
    displayedContentTypes: parseValue<string>(a[52]),
    viewedPluginKey: parseValue<string>(a[53]),
    viewedPluginContext: parseValue<string>(a[54]),
    quickReplyType: parseValue<string>(a[55]),
    hotEmojiSize: parseValue<string>(a[56]),
    replySourceTimestampMs: getAsMS(parseValue<string>(a[57])),
    ephemeralDurationInSec: parseValue<string>(a[58]),
    msUntilExpirationTs: getAsMS(parseValue<string>(a[59])),
    ephemeralExpirationTs: getAsMS(parseValue<string>(a[60])),
    takedownState: parseValue<string>(a[61]),
    isCollapsed: parseValue<boolean>(a[62]),
    subthreadKey: parseValue<string>(a[63]),
  }),
  upsertReaction: (a: RawItem) => ({
    raw: JSON.stringify(a),
    threadKey: a[0][1],
    timestampMs: getAsDate(a[1][1]),
    messageId: a[2],
    actorId: a[3][1],
    reaction: fixEmoji(getAsString(a[4])),
  }),
  addParticipantIdToGroupThread: (a: RawItem): DBParticipantInsert => ({
    raw: JSON.stringify(a),
    threadKey: a[0][1],
    userId: a[1][1],
    readWatermarkTimestampMs: getAsDate(a[2][1]),
    readActionTimestampMs: getAsDate(a[3][1]),
    deliveredWatermarkTimestampMs: getAsDate(a[4][1]),
    // lastDeliveredWatermarkTimestampMs: getAsDate(a[5][1])),
    lastDeliveredActionTimestampMs: a[5][1] ? getAsDate(a[5][1]) : null,
    isAdmin: Boolean(a[6]),
  }),
  removeParticipantFromThread: (a: RawItem) => ({
    raw: JSON.stringify(a),
    threadKey: parseValue<string>(a[0]),
    userId: parseValue<string>(a[1]),
  }),
  verifyContactRowExists: (a: RawItem): IGContact => ({
    raw: JSON.stringify(a),
    id: a[0][1],
    profilePictureUrl: a[2] == null ? '' : a[2],
    name: a[3],
    username: a[20],
    profilePictureFallbackUrl: a[5],
    // name: d[0],
    secondaryName: a[20],
    // normalizedNameForSearch: d[0],
    isMemorialized: a[9],
    blockedByViewerStatus: parseValue(a[11]),
    canViewerMessage: a[12],
    // profilePictureLargeUrl: '',
    // isMessengerUser: !0,
    // rank: 0,
    contactType: parseValue(a[4]),
    // contactTypeExact: c.i64.cast([0, 0]),
    // requiresMultiway: !1,
    authorityLevel: parseValue(a[14]),
    // workForeignEntityType: c.i64.cast([0, 0]),
    capabilities: parseValue(a[15]),
    capabilities2: parseValue(a[16]),
    contactViewerRelationship: parseValue(a[19]),
    gender: parseValue(a[18]),
  }),
  deleteThenInsertContact: (a: RawItem) => ({
    id: a[0][1],
    profilePictureUrl: a[2] == null ? '' : a[2],
    name: a[9],
    username: a[41],
  }),
  insertBlobAttachment: (a: RawItem): IGAttachment => ({
    raw: JSON.stringify(a),
    filename: a[0],
    threadKey: a[27][1],
    messageId: a[32],
    previewUrl: a[8],
    previewUrlFallback: a[9],
    previewUrlExpirationTimestampMs: getAsMS(a[10][1]),
    previewUrlMimeType: parseValue<string>(a[11]),
    previewWidth: Number(parseValue<string>(a[14])),
    previewHeight: Number(parseValue<string>(a[15])),
    timestampMs: getAsMS(a[31][1]),
    attachmentType: parseValue<string>(a[29]),
    attachmentFbid: a[34],
    filesize: Number(parseValue<string>(a[1])),
    hasMedia: Boolean(a[2]),
    playableUrl: a[3],
    playableUrlFallback: a[4],
    playableUrlExpirationTimestampMs: getAsMS(a[5][1]),
    playableUrlMimeType: parseValue<string>(a[6]),
    dashManifest: parseValue<string>(a[7]),
    miniPreview: parseValue<string>(a[13]),
    attributionAppId: parseValue<string>(a[16]),
    attributionAppName: parseValue<string>(a[17]),
    isSharable: !1,
    attributionAppIcon: parseValue<string>(a[18]),
    attributionAppIconFallback: parseValue<string>(a[19]),
    attributionAppIconUrlExpirationTimestampMs: getAsMS(a[20]),
    localPlayableUrl: parseValue<string>(a[21]),
    playableDurationMs: getAsMS(a[22]),
    attachmentIndex: parseValue<string>(a[23]),
    accessibilitySummaryText: parseValue<string>(a[24]),
    isPreviewImage: Boolean(a[25]),
    originalFileHash: parseValue<string>(a[26]),
    offlineAttachmentId: parseValue<string>(a[33]), // @TODO: is integer/bigint?
    hasXma: Boolean(a[35]),
    xmaLayoutType: parseValue<string>(a[36]),
    xmasTemplateType: parseValue<string>(a[37]),
    titleText: parseValue<string>(a[38]),
    subtitleText: parseValue<string>(a[39]),
    descriptionText: parseValue<string>(a[40]),
    sourceText: parseValue<string>(a[41]),
    faviconUrlExpirationTimestampMs: getAsMS(a[42]),
    isBorderless: Boolean(a[44]),
    previewUrlLarge: parseValue<string>(a[45]),
    samplingFrequencyHz: Number(a[46]),
    waveformData: parseValue<string>(a[47]),
    authorityLevel: parseValue<string>(a[48]),
  }),
  insertXmaAttachment: (a: RawItem): IGAttachment => ({
    raw: JSON.stringify(a),
    threadKey: parseValue<string>(a[25]),
    messageId: parseValue<string>(a[30]),
    attachmentFbid: parseValue<string>(a[32]),
    filename: parseValue<string>(a[1]),
    filesize: parseValue<number>(a[2]),
    hasMedia: !1,
    isSharable: parseValue<boolean>(a[3]),
    playableUrl: parseValue<string>(a[4]),
    playableUrlFallback: parseValue<string>(a[5]),
    playableUrlExpirationTimestampMs: getAsMS(parseValue<string>(a[6])),
    playableUrlMimeType: parseValue<string>(a[7]),
    previewUrl: parseValue<string>(a[8]),
    previewUrlFallback: parseValue<string>(a[9]),
    previewUrlExpirationTimestampMs: getAsMS(parseValue<string>(a[10])),
    previewUrlMimeType: parseValue<string>(a[11]),
    previewWidth: parseValue<number>(a[13]),
    previewHeight: parseValue<number>(a[14]),
    attributionAppId: parseValue<string>(a[15]),
    attributionAppName: parseValue<string>(a[16]),
    attributionAppIcon: parseValue<string>(a[17]),
    attributionAppIconFallback: parseValue<string>(a[18]),
    attributionAppIconUrlExpirationTimestampMs: getAsMS(parseValue<string>(a[19])),
    attachmentIndex: parseValue<string>(a[20]),
    accessibilitySummaryText: parseValue<string>(a[21]),
    shouldRespectServerPreviewSize: parseValue<boolean>(a[22]),
    subtitleIconUrl: parseValue<string>(a[23]),
    shouldAutoplayVideo: parseValue<boolean>(a[24]),
    attachmentType: parseValue<string>(a[27]),
    timestampMs: getAsMS(parseValue<string>(a[29])),
    offlineAttachmentId: parseValue<string>(a[31]),
    hasXma: !0,
    xmaLayoutType: parseValue<string>(a[33]),
    xmasTemplateType: parseValue<string>(a[34]),
    collapsibleId: parseValue<string>(a[35]),
    defaultCtaId: parseValue<string>(a[36]),
    defaultCtaTitle: parseValue<string>(a[37]),
    defaultCtaType: parseValue<string>(a[38]),
    attachmentCta1Id: parseValue<string>(a[40]),
    cta1Title: parseValue<string>(a[41]),
    cta1IconType: parseValue<string>(a[42]),
    cta1Type: parseValue<string>(a[43]),
    attachmentCta2Id: parseValue<string>(a[45]),
    cta2Title: parseValue<string>(a[46]),
    cta2IconType: parseValue<string>(a[47]),
    cta2Type: parseValue<string>(a[48]),
    attachmentCta3Id: parseValue<string>(a[50]),
    cta3Title: parseValue<string>(a[51]),
    cta3IconType: parseValue<string>(a[52]),
    cta3Type: parseValue<string>(a[53]),
    imageUrl: parseValue<string>(a[54]),
    imageUrlFallback: parseValue<string>(a[55]),
    imageUrlExpirationTimestampMs: getAsMS(parseValue<string>(a[56])),
    actionUrl: parseValue<string>(a[57]),
    titleText: parseValue<string>(a[58]),
    subtitleText: parseValue<string>(a[59]),
    maxTitleNumOfLines: parseValue<string>(a[60]),
    maxSubtitleNumOfLines: parseValue<string>(a[61]),
    descriptionText: parseValue<string>(a[62]),
    sourceText: parseValue<string>(a[63]),
    faviconUrl: parseValue<string>(a[64]),
    faviconUrlFallback: parseValue<string>(a[65]),
    faviconUrlExpirationTimestampMs: getAsMS(parseValue<string>(a[66])),
    listItemsId: parseValue<string>(a[68]),
    listItemsDescriptionText: parseValue<string>(a[69]),
    listItemsDescriptionSubtitleText: parseValue<string>(a[70]),
    listItemsSecondaryDescriptionText: parseValue<string>(a[71]),
    listItemId1: parseValue<string>(a[72]),
    listItemTitleText1: parseValue<string>(a[73]),
    listItemContactUrlList1: parseValue<string>(a[74]),
    listItemProgressBarFilledPercentage1: parseValue<string>(a[75]),
    listItemContactUrlExpirationTimestampList1: parseValue<string>(a[76]),
    listItemContactUrlFallbackList1: parseValue<string>(a[77]),
    listItemAccessibilityText1: parseValue<string>(a[78]),
    listItemTotalCount1: parseValue<string>(a[79]),
    listItemId2: parseValue<string>(a[80]),
    listItemTitleText2: parseValue<string>(a[81]),
    listItemContactUrlList2: parseValue<string>(a[82]),
    listItemProgressBarFilledPercentage2: parseValue<string>(a[83]),
    listItemContactUrlExpirationTimestampList2: parseValue<string>(a[84]),
    listItemContactUrlFallbackList2: parseValue<string>(a[85]),
    listItemAccessibilityText2: parseValue<string>(a[86]),
    listItemTotalCount2: parseValue<string>(a[87]),
    listItemId3: parseValue<string>(a[88]),
    listItemTitleText3: parseValue<string>(a[89]),
    listItemContactUrlList3: parseValue<string>(a[90]),
    listItemProgressBarFilledPercentage3: parseValue<string>(a[91]),
    listItemContactUrlExpirationTimestampList3: parseValue<string>(a[92]),
    listItemContactUrlFallbackList3: parseValue<string>(a[93]),
    listItemAccessibilityText3: parseValue<string>(a[94]),
    listItemTotalCount3: parseValue<string>(a[95]),
    isBorderless: parseValue<boolean>(a[99]),
    headerImageUrlMimeType: parseValue<string>(a[100]),
    headerTitle: parseValue<string>(a[101]),
    headerSubtitleText: parseValue<string>(a[102]),
    headerImageUrl: parseValue<string>(a[103]),
    headerImageUrlFallback: parseValue<string>(a[104]),
    headerImageUrlExpirationTimestampMs: getAsMS(parseValue<string>(a[105])),
    previewImageDecorationType: parseValue<string>(a[106]),
    shouldHighlightHeaderTitleInTitle: parseValue<string>(a[107]),
    targetId: parseValue<string>(a[108]),
    attachmentLoggingType: parseValue<string>(a[111]),
    previewUrlLarge: parseValue<string>(a[113]),
    gatingType: parseValue<string>(a[114]),
    gatingTitle: parseValue<string>(a[115]),
    targetExpiryTimestampMs: getAsMS(parseValue<string>(a[116])),
    countdownTimestampMs: getAsMS(parseValue<string>(a[117])),
    shouldBlurSubattachments: parseValue<string>(a[118]),
    verifiedType: parseValue<string>(a[119]),
    captionBodyText: parseValue<string>(a[120]),
    isPublicXma: parseValue<string>(a[121]),
    authorityLevel: parseValue<string>(a[122]),
  }),
  upsertSyncGroupThreadsRange: (a: RawItem) => ({
    syncGroup: parseValue<number>(a[0]),
    parentThreadKey: parseValue<number>(a[1]),
    minLastActivityTimestampMs: parseValue<number>(a[2]),
    hasMoreBefore: a[3] as unknown as boolean,
    isLoadingBefore: a[4] as unknown as boolean,
    minThreadKey: parseValue<string>(a[5]),
  }),
  insertSearchResult: (a: RawItem) => ({
    // query: a[0],
    id: a[1],
    // type of [1] is user
    // type of [2] is group chat
    type: (a[4][1] === '1' ? 'user' : a[4][1] === '2' ? 'group' : 'unknown_user') as SearchArgumentType,
    fullName: a[5],
    imgURL: a[6],
    username: a[8],
    // messageId: a[9],
    // messageTimestampMs: new Date(Number(a[10])),
    // isVerified: Boolean(a[12]),
  }),
  insertNewMessageRange: (a: RawItem) => ({
    threadKey: a[0],
    minTimestamp: a[1],
    maxTimestamp: a[2],
    minMessageId: a[3],
    maxMessageId: a[4],
    hasMoreBeforeFlag: parseValue<boolean>(a[7]),
    hasMoreAfterFlag: parseValue<boolean>(a[8]),
  }),
  updateExistingMessageRange: (a: RawItem) => {
    const isMaxTimestamp = Boolean(a[2])
    return {
      threadKey: a[0],
      hasMoreBeforeFlag: a[2] && !a[3],
      hasMoreAfterFlag: !a[2] && !a[3],
      maxTimestamp: isMaxTimestamp ? a[1] : undefined,
      minTimestamp: !isMaxTimestamp ? a[1] : undefined,
    }
  },
  insertMessage: (a: RawItem): IGMessage => ({
    raw: JSON.stringify(a),
    links: null,
    threadKey: parseValue<string>(a[3]),
    timestampMs: getAsMS(parseValue<string>(a[5])),
    messageId: parseValue<string>(a[8]),
    offlineThreadingId: parseValue<string>(a[9]),
    authorityLevel: parseValue<number>(a[2]),
    primarySortKey: parseValue<string>(a[6]),
    senderId: parseValue<string>(a[10]),
    isAdminMessage: parseValue<boolean>(a[12]),
    sendStatus: parseValue<string>(a[15]),
    sendStatusV2: parseValue<string>(a[16]),
    text: parseValue<string>(a[0]),
    subscriptErrorMessage: parseValue<string>(a[1]),
    secondarySortKey: parseValue<string>(a[7]),
    stickerId: parseValue<string>(a[11]),
    messageRenderingType: parseValue<string>(a[13]),
    isUnsent: parseValue<boolean>(a[17]),
    unsentTimestampMs: getAsMS(parseValue<string>(a[18])),
    mentionOffsets: parseValue<string>(a[19]),
    mentionLengths: parseValue<string>(a[20]),
    mentionIds: parseValue<string>(a[21]),
    mentionTypes: parseValue<string>(a[22]),
    replySourceId: parseValue<string>(a[23]),
    replySourceType: parseValue<string>(a[24]),
    replySourceTypeV2: parseValue<string>(a[25]),
    replyStatus: parseValue<string>(a[26]),
    replySnippet: parseValue<string>(a[27]),
    replyMessageText: parseValue<string>(a[28]),
    replyToUserId: parseValue<string>(a[29]),
    replyMediaExpirationTimestampMs: getAsMS(parseValue<string>(a[30])),
    replyMediaUrl: parseValue<string>(a[31]),
    replyMediaPreviewWidth: parseValue<string>(a[33]),
    replyMediaPreviewHeight: parseValue<string>(a[34]),
    replyMediaUrlMimeType: parseValue<string>(a[35]),
    replyMediaUrlFallback: parseValue<string>(a[36]),
    replyCtaId: parseValue<string>(a[37]),
    replyCtaTitle: parseValue<string>(a[38]),
    replyAttachmentType: parseValue<string>(a[39]),
    replyAttachmentId: parseValue<string>(a[40]),
    replyAttachmentExtra: parseValue<string>(a[41]),
    isForwarded: parseValue<boolean>(a[42]),
    forwardScore: parseValue<string>(a[43]),
    hasQuickReplies: parseValue<boolean>(a[44]),
    adminMsgCtaId: parseValue<string>(a[45]),
    adminMsgCtaTitle: parseValue<string>(a[46]),
    adminMsgCtaType: parseValue<string>(a[47]),
    cannotUnsendReason: parseValue<string>(a[48]),
    textHasLinks: parseValue<number>(a[49]),
    viewFlags: parseValue<string>(a[50]),
    displayedContentTypes: parseValue<string>(a[51]),
    viewedPluginKey: parseValue<string>(a[52]),
    viewedPluginContext: parseValue<string>(a[53]),
    quickReplyType: parseValue<string>(a[54]),
    hotEmojiSize: parseValue<string>(a[55]),
    replySourceTimestampMs: getAsMS(parseValue<string>(a[56])),
    ephemeralDurationInSec: parseValue<string>(a[57]),
    msUntilExpirationTs: getAsMS(parseValue<string>(a[58])),
    ephemeralExpirationTs: getAsMS(parseValue<string>(a[59])),
    takedownState: parseValue<string>(a[60]),
    isCollapsed: parseValue<boolean>(a[61]),
    subthreadKey: parseValue<string>(a[62]),
  }),
  updateThreadMuteSetting: (a: RawItem) => ({
    threadKey: a[0][1],
    muteExpireTimeMs: getAsMS(a[1][1]),
  }),
  syncUpdateThreadName: (a: RawItem) => ({
    threadName: a[0],
    threadKey: a[1][1],
  }),
  updateThreadParticipantAdminStatus: (a: RawItem) => ({
    threadKey: a[0][1],
    participantId: a[1][1],
    isAdmin: Boolean(a[2]),
  }),
  replaceOptimsiticMessage: (a: RawItem) => ({
    offlineThreadingId: a[0],
    messageId: a[1],
  }),
  replaceOptimisticThread: (a: RawItem) => ({
    offlineThreadingId: parseValue<string>(a[0]),
    threadId: parseValue<string>(a[1]),
  }),
  updateReadReceipt: (a: RawItem) => ({
    raw: JSON.stringify(a),
    readWatermarkTimestampMs: getAsMS(a[0][1]), // last message logged in user has read from
    threadKey: a[1][1],
    contactId: a[2][1],
    readActionTimestampMs: getAsMS(a[3][1]),
  }),
  insertAttachmentItem: (a: RawItem) => ({
    attachmentFbid: a[0],
    threadKey: a[2][1],
    messageId: a[4],
    previewUrl: a[17],
  }),
  insertAttachmentCta: (a: RawItem) => ({
    raw: JSON.stringify(a),
    attachmentFbid: a[1],
    threadKey: a[3][1],
    messageId: a[5],
    actionUrl: parseValue<string>(a[9]),
  }),
  deleteReaction: (a: RawItem) => ({
    threadKey: a[0][1],
    messageId: a[1],
    actorId: a[2][1],
  }),
  verifyThreadExists: (a: RawItem) => ({
    threadKey: a[0][1],
  }),
  deleteMessage: (a: RawItem) => ({
    threadKey: a[0][1],
    messageId: a[1],
  }),
  removeOptimisticGroupThread: (a: RawItem) => ({
    offlineThreadingId: parseValue<string>(a[0]),
  }),
  taskExists: (a: RawItem) => ({
    taskId: parseValue<string>(a[0]),
  }),
  issueNewError: (a: RawItem) => ({
    requestId: parseValue<string>(a[0]),
    errorId: parseValue<string>(a[1]), // @TODO: not sure what this value is
    errorTitle: parseValue<string>(a[2]),
    errorMessage: parseValue<string>(a[3]),
  }),
  updateDeliveryReceipt: (a: RawItem) => ({
    raw: JSON.stringify(a), // [19,\"1691805678773\"],[19,\"9859151144155618\"],[19,\"17844105197232431\"],[19,\"1691805679040\"]]]
  }),
  deleteThread: (a: RawItem) => ({
    raw: JSON.stringify(a),
    threadKey: parseValue<string>(a[0]),
  }),
} as const

export type ParseResult = {
  [K in keyof typeof parseMap]: ReturnType<typeof parseMap[K]>;
}

// ResultType is an object with the same keys as parseMap,
// and each value is an array of the inferred return type of the corresponding parse function.
type ResultType = {
  [K in keyof typeof parseMap]: ParseResult[K][];
}

function interestedOperation(operation: any[]) {
  if (operation[0] === 5 && operation[1] in parseMap) {
    return parseMap[operation[1]](operation.slice(2))
  }
}

function recursiveParse(arr: any[]) {
  const res: Partial<ResultType> = {}
  for (const item of arr) {
    if (Array.isArray(item)) {
      const interested = interestedOperation(item)
      if (interested) {
        if (res[item[1]]) {
          res[item[1]].push(interested)
        }
        res[item[1]] = [interested]
      } else {
        const result = recursiveParse(item)
        if (Object.keys(result).length > 0) {
          //  for each key in result if the key is in res then concat the arrays
          for (const key in result) {
            if (res[key]) {
              res[key] = res[key].concat(result[key])
            } else {
              res[key] = result[key]
            }
          }
        }
      }
    }
  }
  return res
}

export function parseRawPayload(payload: string) {
  const j = JSON.parse(payload)
  return {
    ...recursiveParse(j.step),
    cursor: j.step[2][1]?.[3]?.[5] as string,
  }
}

export type ParsedPayload = ReturnType<typeof parseRawPayload>
